Index: pacman.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\nimport pygame\nimport random\nimport math\npygame.init()\n\nscore = 0 #счетчик очков\ngame_over_font = pygame.font.SysFont(\"Arial\", 60)\n\nclass Pacman:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.size = 20\n        self.direction = 'right'\n        self.visibility = 75\n\n    def draw(self):\n        pygame.draw.circle(sc, (255,255,0), (self.x + SIZE_ONE_CELL/2, self.y + SIZE_ONE_CELL/2), self.size)\n    def move(self):\n        pygame.draw.circle(sc, (0, 0, 0), (self.x + SIZE_ONE_CELL/2, self.y + SIZE_ONE_CELL/2), self.size)\n        if self.direction == 'up':\n            for wall in walls:\n                if self.y - SIZE_ONE_CELL == wall[1] and self.x == wall[0]:\n                    return\n            if self.y == 0:\n                return\n            self.y -= SIZE_ONE_CELL\n        elif self.direction == 'down':\n            for wall in walls:\n                if self.y + SIZE_ONE_CELL == wall[1] and self.x == wall[0]:\n                    return\n            if self.y == SIZE - SIZE_ONE_CELL:\n                return\n            self.y += SIZE_ONE_CELL\n        elif self.direction == 'right':\n            for wall in walls:\n                if self.y == wall[1] and self.x + SIZE_ONE_CELL == wall[0]:\n                    return\n            if self.x ==SIZE-SIZE_ONE_CELL:\n                return\n            self.x += SIZE_ONE_CELL\n        elif self.direction == 'left':\n            for wall in walls:\n                if self.y == wall[1] and self.x - SIZE_ONE_CELL == wall[0]:\n                    return\n            if self.x == 0:\n                return\n            self.x -= SIZE_ONE_CELL\n\n#считываю из файла координаты стен\ndef read_list_from_line(filename, line_number, separator=' '):\n    result = []\n    try:\n        with open(filename, 'r') as file:\n            lines = file.readlines()\n            line = lines[line_number-1].strip()\n            list_data = line.split(separator)\n            formatted_list = [x for x in list_data]\n            for item in formatted_list:\n                item = item.replace('[', '').replace(']', '')\n                result.append(item)\n                res = [int(item.replace(',', '')) for item in result]\n                r = list(zip(res[::2], res[1::2]))\n            return r\n    except:\n        print(\"Ошибка\")\n\nCOUNT_OF_CELL = 11\nSIZE_ONE_CELL = 50\nSIZE = COUNT_OF_CELL * SIZE_ONE_CELL\nCOUNT_OF_WALL =8\nCOUNT_OF_AWARDS = 50\n\npacman = Pacman(SIZE/2 - SIZE_ONE_CELL/2, SIZE/2 - SIZE_ONE_CELL/2)\n\nsc = pygame.display.set_mode((SIZE, SIZE))\npygame.display.set_caption('pacman')\n\n#добавляем стены\nrandom_number_of_maps = random.randint(1,100)\nwalls_ = read_list_from_line('maps.txt', random_number_of_maps)\nwalls = []\n#for w in walls_:\n#   walls.append(list(w))\n\n#строим награды\nawards = []\nscore_font = pygame.font.SysFont(\"Arial\", 24)\na = 0\nwhile( a != COUNT_OF_AWARDS ):\n    cross = False\n    random_XY = [random.randint(0, SIZE) for i in range(2)]\n    random_XY = [int(random_XY[i] - random_XY[i] % SIZE_ONE_CELL) for i in range(2)]\n    for wall in walls:\n        if random_XY == wall:\n            cross = True\n    for aw in awards:\n        if random_XY[1] == aw[1] and random_XY[0] == aw[0]:\n            cross = True\n    if random_XY[0] == pacman.x and random_XY[1] == pacman.y:\n        cross = True\n    if cross == False:\n        awards.append([random_XY[0], random_XY[1]])\n        a += 1\n\ndef score_count():\n    global score\n    for a in awards:\n        if(int(a[0]) == pacman.x and int(a[1]) == pacman.y):\n            awards.remove(a)\n            score += 1\n    score_text = score_font.render(\"Счёт: {}\".format(score), True, (255, 255, 255))  # для отображения\n    sc.blit(score_text, (2, 2))\n\npacman.draw()\ndef create_map():\n    #строю стены\n    for w in walls:\n        pygame.draw.rect(sc, (200, 200, 200), (w[0], w[1], SIZE_ONE_CELL, SIZE_ONE_CELL))\n    #строю награды\n    for award in awards:\n        pygame.draw.circle(sc, (50, 100, 150), (award[0] + SIZE_ONE_CELL / 2, award[1] + SIZE_ONE_CELL / 2), SIZE_ONE_CELL / 4)\n    #строю клетки\n    for i in range(SIZE):\n        if i % SIZE_ONE_CELL == 0:\n            pygame.draw.line(sc, (255, 0, 255), (0, i), (SIZE, i), 1)\n            pygame.draw.line(sc, (255, 0, 255), (i, 0), (i, SIZE), 1)\n\nfog_of_war = pygame.Surface((SIZE, SIZE))\nfog_of_war.fill((0, 0, 0))\ndef visibility():\n    pygame.draw.rect(fog_of_war, (60, 60, 60), (pacman.x + 25-pacman.visibility, pacman.y + 25-pacman.visibility,pacman.visibility*2, pacman.visibility*2), 0)\n    fog_of_war.set_colorkey((60, 60, 60))\n    sc.blit(fog_of_war, (0, 0))\n    pygame.display.flip()\n\nmap = [[i, j, 0] for i in range(SIZE) for j in range(SIZE) if (i % SIZE_ONE_CELL == 0) and (j % SIZE_ONE_CELL == 0)]\n\ndef clear_fog(m):\n    if walls.count([m[0], m[1]]):\n        m[2] = 2\n    elif awards.count([m[0], m[1]]):\n        m[2] = 3\n    else:\n        m[2] = 1\nfor m in map:\n    if [m[0], m[1]] in [[200, 200], [250, 200], [300, 200], [200, 250], [250, 250], [300, 250], [200, 300], [250, 300], [300, 300]]:\n        clear_fog(m)\n\nfor i in range(SIZE // SIZE_ONE_CELL):\n    for j in range(0, len(map), SIZE // SIZE_ONE_CELL):\n        print(map[i+j][2], end=\" \")\n    print()\nprint()\ndef alghoritm_move():\n    three = []\n    for m in map:\n        if m[2] == 3:\n            move = []\n            move_x = int((m[0] - pacman.x)/SIZE_ONE_CELL)\n            move_y = int((m[1] - pacman.y)/SIZE_ONE_CELL)\n            if move_x < 0:\n                for x in range(abs(move_x)):\n                    move.append('l')\n            if move_x > 0:\n                for x in range(abs(move_x)):\n                    move.append('r')\n            if move_y < 0:\n                for x in range(abs(move_y)):\n                    move.append('u')\n            if move_y > 0:\n                for x in range(abs(move_y)):\n                    move.append('d')\n            move.append(m)\n            three.append(move)\n    best_way = []\n    if three:\n        best_way = min(three, key=len)\n        best_way[-1][2] = 1\n        best_way.pop()\n    else:\n        random_way = random.randint(1, 4)\n        if random_way == 1:\n            best_way.append('r')\n        if random_way == 2:\n            best_way.append('l')\n        if random_way == 3:\n            best_way.append('u')\n        if random_way == 4:\n            best_way.append('d')\n    currentXY = [pacman.x, pacman.y]\n    for bv in best_way:\n        if bv == 'l':\n            for m in map:\n                if [m[0], m[1]] in [[currentXY[0] * SIZE_ONE_CELL, currentXY[1]], [currentXY[0] - 2 * SIZE_ONE_CELL, currentXY[1] - SIZE_ONE_CELL], [currentXY[0] - 2 * SIZE_ONE_CELL, currentXY[1] + SIZE_ONE_CELL]]:\n                    clear_fog(m)\n            currentXY[0] = currentXY[0] - SIZE_ONE_CELL\n        elif bv == 'r':\n            for m in map:\n                if [m[0], m[1]] in [[currentXY[0] + 2 * SIZE_ONE_CELL, currentXY[1]], [currentXY[0] + 2 * SIZE_ONE_CELL, currentXY[1] - SIZE_ONE_CELL], [currentXY[0] + 2 * SIZE_ONE_CELL, currentXY[1] + SIZE_ONE_CELL]]:\n                    clear_fog(m)\n            currentXY[0] = currentXY[0] + SIZE_ONE_CELL\n        elif bv == 'u':\n            for m in map:\n                if [m[0], m[1]] in [[currentXY[0], currentXY[1] - 2 * SIZE_ONE_CELL], [currentXY[0] - SIZE_ONE_CELL, currentXY[1] - 2 * SIZE_ONE_CELL], [currentXY[0] + SIZE_ONE_CELL, currentXY[1] - 2* SIZE_ONE_CELL]]:\n                    clear_fog(m)\n            currentXY[1] = currentXY[1] - SIZE_ONE_CELL\n        elif bv == 'd':\n            for m in map:\n                if [m[0], m[1]] in [[currentXY[0], currentXY[1] + 2 * SIZE_ONE_CELL], [currentXY[0] - SIZE_ONE_CELL, currentXY[1] + 2 * SIZE_ONE_CELL], [currentXY[0] + SIZE_ONE_CELL, currentXY[1] + 2 * SIZE_ONE_CELL]]:\n                    clear_fog(m)\n            currentXY[1] = currentXY[1] + SIZE_ONE_CELL\n    for i in range(SIZE // SIZE_ONE_CELL):\n        for j in range(0, len(map), SIZE // SIZE_ONE_CELL):\n            print(map[i+j][2], end=\" \")\n        print()\n    print()\n    return best_way\n\ncreate_map()\nvisibility()\npygame.display.flip()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            exit()\n        if score == COUNT_OF_AWARDS:\n            time.sleep(1)\n            exit()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_RIGHT:\n                pacman.direction = \"right\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_LEFT:\n                pacman.direction = \"left\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_UP:\n                pacman.direction = \"up\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_DOWN:\n                pacman.direction = \"down\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_SPACE:\n                for i in range(200):\n                    move = alghoritm_move()\n                    for m in move:\n                        directions = {'r' : \"right\", 'l' :\"left\", 'u':\"up\", 'd':\"down\"}\n                        pacman.direction = directions[m]\n                        pacman.move()\n                        create_map()\n                        visibility()\n                        score_count()\n                        pacman.draw()\n                        pygame.display.flip()\n                        pygame.time.delay(200)\n    pygame.draw.rect(sc, (0, 0, 0), (2, 2, 90, 25))\n    score_count()\n    pacman.draw()\n    pygame.display.flip()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pacman.py b/pacman.py
--- a/pacman.py	
+++ b/pacman.py	
@@ -81,8 +81,8 @@
 random_number_of_maps = random.randint(1,100)
 walls_ = read_list_from_line('maps.txt', random_number_of_maps)
 walls = []
-#for w in walls_:
-#   walls.append(list(w))
+for w in walls_:
+   walls.append(list(w))
 
 #строим награды
 awards = []
