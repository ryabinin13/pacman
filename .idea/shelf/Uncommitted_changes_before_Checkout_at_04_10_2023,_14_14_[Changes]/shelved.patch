Index: pacman.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\nimport pygame\nimport random\npygame.init()\n\nscore = 0 #счетчик очков\ngame_over_font = pygame.font.SysFont(\"Arial\", 60)\n\nclass Pacman:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.size = 20\n        self.direction = 'right'\n        self.visibility = 75\n\n    def draw(self):\n        pygame.draw.circle(sc, (255,255,0), (self.x, self.y), self.size)\n    def move(self):\n        pygame.draw.circle(sc, (0, 0, 0), (self.x, self.y), self.size)\n        if self.direction == 'up':\n            for wall in walls:\n                if self.y - self.size >= wall[1]  and self.y - self.size <= wall[1] + SIZE_ONE_CELL*2 and self.x >= wall[0] and self.x <= wall[0] + SIZE_ONE_CELL:\n                    return\n            if self.y <= SIZE_ONE_CELL:\n                return\n            if self.y > 0:\n                self.y -= SIZE_ONE_CELL\n        elif self.direction == 'down':\n            for wall in walls:\n                if self.y + self.size >= wall[1] - SIZE_ONE_CELL and self.y + self.size <= wall[1] + SIZE_ONE_CELL and self.x >= wall[0] and self.x <= wall[0] + SIZE_ONE_CELL:\n                    return\n            if self.y >=SIZE-SIZE_ONE_CELL:\n                return\n            if self.y < SIZE - self.size:\n                self.y += SIZE_ONE_CELL\n        elif self.direction == 'right':\n            for wall in walls:\n                if self.x + self.size >= wall[0] - SIZE_ONE_CELL and self.x + self.size <= wall[0] + SIZE_ONE_CELL and self.y >= wall[1] and self.y <= wall[1] +SIZE_ONE_CELL:\n                    return\n            if self.x >=SIZE-SIZE_ONE_CELL:\n                return\n            if self.x < SIZE - self.size:\n                self.x += SIZE_ONE_CELL\n        elif self.direction == 'left':\n            for wall in walls:\n                if self.x - self.size >= wall[0] and self.x - self.size <= wall[0] + SIZE_ONE_CELL*2 and self.y >= wall[1] and self.y <= wall[1] + SIZE_ONE_CELL:\n                    return\n            if self.x <=SIZE_ONE_CELL:\n                return\n            if self.x > 0:\n                self.x -= SIZE_ONE_CELL\n\n#считываю из файла координаты стен\ndef read_list_from_line(filename, line_number, separator=' '):\n    result = []\n    try:\n        with open(filename, 'r') as file:\n            lines = file.readlines()\n            line = lines[line_number-1].strip()\n            list_data = line.split(separator)\n            formatted_list = [x for x in list_data]\n            for item in formatted_list:\n                item = item.replace('[', '').replace(']', '')\n                result.append(item)\n                res = [int(item.replace(',', '')) for item in result]\n                r = list(zip(res[::2], res[1::2]))\n            return r\n    except:\n        print(\"Ошибка\")\n\nCOUNT_OF_CELL = 11\nSIZE_ONE_CELL = 50\nSIZE = COUNT_OF_CELL * SIZE_ONE_CELL\nCOUNT_OF_WALL =8\nCOUNT_OF_AWARDS = 10\n\npacman = Pacman(SIZE/2, SIZE/2)\nsc = pygame.display.set_mode((SIZE, SIZE))\npygame.display.set_caption('pacman')\n\n#добавляем стены\nrandom_number_of_maps = random.randint(1,100)\n\nwalls_ = read_list_from_line('maps.txt', random_number_of_maps)\nwalls = []\nfor w in walls_:\n   walls.append(list(w))\n\n#строим награды\nawards = []\nscore_font = pygame.font.SysFont(\"Arial\", 24)\na = 0\nwhile( a != COUNT_OF_AWARDS ):\n    cross = False\n    random_XY = [random.randint(0, SIZE) for i in range(2)]\n    random_XY = [int(random_XY[i] - random_XY[i] % SIZE_ONE_CELL) for i in range(2)]\n    for wall in walls:\n        if random_XY == wall:\n            cross = True\n    random_XY = [int(random_XY[i] + SIZE_ONE_CELL / 2) for i in range(2)]\n    for aw in awards:\n        if random_XY[1] == aw[1] and random_XY[0] == aw[0]:\n            cross = True\n    if cross == False:\n        awards.append((random_XY[0], random_XY[1]))\n        a += 1\n\ndef score_count():\n    global score\n    for a in awards:\n        if(int(a[0]) == pacman.x and int(a[1]) == pacman.y):\n            awards.remove(a)\n            score += 1\n    score_text = score_font.render(\"Счёт: {}\".format(score), True, (255, 255, 255))  # для отображения\n    sc.blit(score_text, (2, 2))\n\npacman.draw()\n#коордитнаты пакманы в прошлые ходы\ndef create_map():\n    #строю стены\n    for w in walls:\n        pygame.draw.rect(sc, (200, 200, 200), (w[0], w[1], SIZE_ONE_CELL, SIZE_ONE_CELL))\n    #строю награды\n    for award in awards:\n        pygame.draw.circle(sc, (50, 100, 150), (award[0], award[1]), SIZE_ONE_CELL / 4)\n    #строю клетки\n    for i in range(SIZE):\n        if i % SIZE_ONE_CELL == 0:\n            pygame.draw.line(sc, (255, 0, 255), (0, i), (SIZE, i), 1)\n            pygame.draw.line(sc, (255, 0, 255), (i, 0), (i, SIZE), 1)\nfog_of_war = pygame.Surface((SIZE, SIZE))\nfog_of_war.fill((0, 0, 0))\ndef visibility():\n    pygame.draw.circle(fog_of_war, (60, 60, 60), (pacman.x, pacman.y), pacman.visibility, 0)\n    fog_of_war.set_colorkey((60, 60, 60))\n    sc.blit(fog_of_war, (0, 0))\n    pygame.display.flip()\ndef move_alghoritm():\n    for award in awards:\n        if int(award[0]) == pacman.x - SIZE_ONE_CELL and int(award[1]) == pacman.y:\n            print(1)\n            return 'l'\n        elif int(award[0]) == pacman.x + SIZE_ONE_CELL and int(award[1]) == pacman.y:\n            print(1)\n            return 'r'\n        elif int(award[0]) == pacman.x and int(award[1]) == pacman.y - SIZE_ONE_CELL:\n            print(1)\n            return 'u'\n        elif int(award[0]) == pacman.x and int(award[1]) == pacman.y + SIZE_ONE_CELL:\n            print(1)\n            return 'd'\n        elif int(award[0]) == pacman.x - SIZE_ONE_CELL and int(award[1]) == pacman.y - SIZE_ONE_CELL:\n            if walls.count([pacman.x - 25, pacman.y - 75]):\n                return 'l'\n            else:\n                return 'u'\n        elif int(award[0]) == pacman.x + SIZE_ONE_CELL and int(award[1]) == pacman.y + SIZE_ONE_CELL:\n            if walls.count([pacman.x - 25, pacman.y + 75]):\n                return 'r'\n            else:\n                return 'd'\n        elif int(award[0]) == pacman.x + SIZE_ONE_CELL and int(award[1]) == pacman.y - SIZE_ONE_CELL:\n            if walls.count([pacman.x - 25, pacman.y - 75]):\n                return 'r'\n            else:\n                return 'u'\n        elif int(award[0]) == pacman.x - SIZE_ONE_CELL and int(award[1]) == pacman.y + SIZE_ONE_CELL:\n            if walls.count([pacman.x - 25, pacman.y + 75]):\n                return 'l'\n            else:\n                return 'd'\n\n    move = random.randint(1, 4)\n    directions = {1: 'r', 2: 'l', 3: 'u', 4: 'd'}\n    return directions[move]\n\ncreate_map()\nvisibility()\npygame.display.flip()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            exit()\n        if score == COUNT_OF_AWARDS:\n            time.sleep(1)\n            exit()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_RIGHT:\n                pacman.direction = \"right\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_LEFT:\n                pacman.direction = \"left\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_UP:\n                pacman.direction = \"up\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_DOWN:\n                pacman.direction = \"down\"\n                pacman.move()\n                create_map()\n                visibility()\n            elif event.key == pygame.K_SPACE:\n                for i in range(200):\n                    move = move_alghoritm()\n                    directions = {'r' : \"right\", 'l' :\"left\", 'u':\"up\", 'd':\"down\"}\n                    pacman.direction = directions[move]\n                    pacman.move()\n                    create_map()\n                    visibility()\n                    score_count()\n                    pacman.draw()\n                    pygame.display.flip()\n                    #pygame.time.delay(500)\n    pygame.draw.rect(sc, (0, 0, 0), (2, 2, 90, 25))\n    score_count()\n    pacman.draw()\n    pygame.display.flip()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pacman.py b/pacman.py
--- a/pacman.py	
+++ b/pacman.py	
@@ -217,7 +217,7 @@
                     score_count()
                     pacman.draw()
                     pygame.display.flip()
-                    #pygame.time.delay(500)
+                    pygame.time.delay(100)
     pygame.draw.rect(sc, (0, 0, 0), (2, 2, 90, 25))
     score_count()
     pacman.draw()
